[project]
name = "vessim"
dynamic = ["version"]
description = "A simulator for carbon-aware applications and systems"
readme = "README.md"
requires-python = ">=3.7"
keywords = ["simulation", "energy system", "testbed", "carbon-aware"]
authors = [{name = "Philipp Wiesner", email = "wiesner@tu-berlin.de"}]
classifiers = [  # Optional
  #   3 - Alpha
  #   4 - Beta
  #   5 - Production/Stable
  "Development Status :: 3 - Alpha",

  # Indicate who your project is intended for
  "Intended Audience :: Developers",
  "Topic :: Software Development :: Build Tools",

  "License :: OSI Approved :: MIT License",

  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3.7",
  "Programming Language :: Python :: 3.8",
  "Programming Language :: Python :: 3.9",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3 :: Only",
]

# This field lists other packages that your project depends on to run.
# Any package you put here will be installed by pip when your project is
# installed, so they must be valid existing projects.
#
# For an analysis of this field vs pip's requirements files see:
# https://packaging.python.org/discussions/install-requires-vs-requirements/
dependencies = [ # Optional
  "peppercorn"
]

# [project.optional-dependencies] # Optional
# dev = ["check-manifest"]
# test = ["coverage"]

[project.urls]  # Optional
"Homepage" = "https://github.com/dos-group/vessim"
"Source" = "https://github.com/dos-group/vessim"
"Bug Reports" = "https://github.com/dos-group/vessim/issues"

# The following would provide a command line executable called `sample`
# which executes the function `main` from this package when invoked.
# [project.scripts]  # Optional
# sample = "sample:main"

[build-system]
# These are the assumed default build requirements from pip:
# https://pip.pypa.io/en/stable/reference/pip/#pep-517-and-518-support
requires = ["setuptools>=43.0.0", "setuptools_scm[toml]>=6.2"]  #, "wheel"
build-backend = "setuptools.build_meta"


[tool.black]
line-length = 90  # Set the maximum characters per line
target-version = ['py311']  # Set python version that black should format the code for
include = '\.py$'  # Format only python files


[tool.ruff]
# Enable Ruff to check for docstring-related (D), pycodestyle-related (E, W), and Pyflakes-related (F) issues
select = ["D", "E", "F", "W"]

# For now the following rules are disabled:
#   D100: Missing docstring in public module
#   D101: Missing docstring in public class
#   D102: Missing docstring in public method
#   D103: Missing docstring in public function
#   D107: Missing docstring in __init__
#   F401: Imported but unused
ignore = ["D100", "D101", "D102", "D103", "D107", "F401"]

# Allow autofix for all enabled rules (when `--fix`) is provided.
fixable = ["D", "E", "W"]
unfixable = ["F"]

line-length = 90  # Set the maximum characters per line (similar to black)
target-version = "py311"  # Set python version for linting (similar to black)
include = ["*.py"]  # Only enable linting for python files (similar to black)

# Exclude specific directories and all defaults
extend-exclude = ["example_node", "simulator/power_meter.py", "carbon-aware_control_unit"]

# Configure Ruff to enforce Google-style docstrings when checking documentation
[tool.ruff.pydocstyle]
convention = "google"


[mypy]
ignore_missing_imports = true
