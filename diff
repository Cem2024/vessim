diff --git a/examples/cosim_sil_example.py b/examples/cosim_sil_example.py
index 46e05fb..a1cecd3 100644
--- a/examples/cosim_sil_example.py
+++ b/examples/cosim_sil_example.py
@@ -28,7 +28,7 @@ COSIM_SIL_CONFIG = {
 }
 RT_FACTOR = 1/60  # 1 wall-clock second ^= 60 sim seconds
 
-GCP_ADDRESS = "http://35.198.148.144"
+GCP_ADDRESS = "http://34.159.232.190"
 RASPI_ADDRESS = "http://192.168.207.71"
 
 disable_mosaik_warnings(behind_threshold=0.01)
@@ -44,7 +44,7 @@ def run_simulation():
     ]
 
     # Initialize computing system
-    consumer_sim = world.start('Consumer', step_size=60)
+    consumer_sim = world.start("Consumer", step_size=60)
     computing_system = consumer_sim.Consumer(
         consumer=ComputingSystem(power_meters=[
             HttpPowerMeter(interval=1, server_address=GCP_ADDRESS),
diff --git a/examples/sil/carbon-aware_control_unit/carbon_aware_control_unit.py b/examples/sil/carbon-aware_control_unit/carbon_aware_control_unit.py
index 6852a0c..adb0cb4 100644
--- a/examples/sil/carbon-aware_control_unit/carbon_aware_control_unit.py
+++ b/examples/sil/carbon-aware_control_unit/carbon_aware_control_unit.py
@@ -1,6 +1,6 @@
 import time
-from vessim.sil.http_client import HTTPClient
-from vessim.sil.stoppable_thread import StoppableThread
+from vessim.sil.http_client import HttpClient
+from vessim.sil.loop_thread import LoopThread
 from threading import Thread
 from typing import Optional
 
@@ -40,13 +40,13 @@ class CarbonAwareControlUnit:
         power_modes: The list of available power modes for the nodes.
         nodes: A dictionary representing the nodes that the Control
             Unit manages, with node IDs as keys and node objects as values.
-        client: The HTTPClient object used to communicate with the server.
+        client: The HttpClient object used to communicate with the server.
     """
 
     def __init__(self, server_address: str, node_ids: list[str]) -> None:
         self.power_modes = ["power-saving", "normal", "high performance"]
         self.node_ids = node_ids
-        self.client = HTTPClient(server_address)
+        self.client = HttpClient(server_address)
         self.nodes_power_mode = {}
         self.battery = RemoteBattery()
         self.ci = 0.0
@@ -63,11 +63,12 @@ class CarbonAwareControlUnit:
     def run_scenario(self, rt_factor: float, update_interval: Optional[float]):
         if update_interval is None:
             update_interval = rt_factor
-        update_thread = StoppableThread(self._update_getter, update_interval)
+        update_thread = LoopThread(self._update_getter, update_interval)
         update_thread.start()
 
         current_time = 0
         while True:
+            update_thread.propagate_exception()
             self.scenario_step(current_time)
             current_time += rt_factor
             time.sleep(rt_factor)
diff --git a/vessim/sil/http_client.py b/vessim/sil/http_client.py
index 77c276b..63f183b 100644
--- a/vessim/sil/http_client.py
+++ b/vessim/sil/http_client.py
@@ -3,15 +3,8 @@ import json
 from typing import Any, Dict
 
 
-class HTTPClientError(Exception):
-    def __init__(self, status_code: int, message: str = ""):
-        self.status_code = status_code
-        self.message = message
-        super().__init__(f"HTTP client error (status code: {status_code}): {message}")
-
-
-class HTTPClient:
-    """Class for making HTTP requests to the VESSIM API server.
+class HttpClient:
+    """Class for making HTTP requests to the Vessim API server.
 
     Args:
         server_address: The address of the server to connect to.
@@ -28,40 +21,33 @@ class HTTPClient:
             route: The path of the endpoint to send the request to.
 
         Raises:
-            HTTPClientError if the data could not be retrieved from route
+            HTTPError if response code is != 200.
 
         Returns:
             A dictionary containing the response.
         """
         response = requests.get(self.server_address + route)
-        if response.status_code == 200:
-            data = response.json() # assuming the response data is in JSON format
-            return data
-
-        raise HTTPClientError(
-            response.status_code,
-            f'Failed to retrieve data from {route}'
-        )
+        if response.status_code != 200:
+            response.raise_for_status()
+        data = response.json() # assuming the response data is in JSON format
+        return data
 
     def put(self, route: str, data: Dict[str, Any]) -> None:
         """Sends a PUT request to the server to update data.
 
         Raises:
-            HTTPClientError if the data could not be updated at route
+            HTTPError if response code is != 200.
 
         Args:
             route: The path of the endpoint to send the request to.
             data: The data to be updated, in dictionary format.
         """
-        headers = {'Content-type': 'application/json'}
+        headers = {"Content-type": "application/json"}
         response = requests.put(
             self.server_address + route,
             data=json.dumps(data),
             headers=headers
         )
         if response.status_code != 200:
-            raise HTTPClientError(
-                response.status_code,
-                f'Failed to update data at {route}'
-            )
+            response.raise_for_status()
 
diff --git a/vessim/sil/loop_thread.py b/vessim/sil/loop_thread.py
index 94a253e..89c3247 100644
--- a/vessim/sil/loop_thread.py
+++ b/vessim/sil/loop_thread.py
@@ -2,16 +2,19 @@ import threading
 import time
 from typing import Callable
 
-class StoppableThread(threading.Thread):
+class LoopThread(threading.Thread):
     """Thread subclass that runs a target function until `stop()` is called.
 
+    Also facilitates the propagation of exceptions to the main thread.
+
     Args:
         target_function: The function to be run in the thread.
 
     Attributes:
-        target_function (Callable): The function to be run in the thread.
-        stop_signal (threading.Event): An event that can be set to signal the
+        target_function: The function to be run in the thread.
+        stop_signal: An event that can be set to signal the
             thread to stop.
+        exc: Variable that is set to propagate an exception to the main thread.
     """
 
     def __init__(self, target_function: Callable[[], None], interval: float):
@@ -19,14 +22,25 @@ class StoppableThread(threading.Thread):
         self.target_function = target_function
         self.stop_signal = threading.Event()
         self.interval = interval
+        self.exc = None
 
     def run(self):
         """Run the target function in a loop until the stop signal is set."""
-        while not self.stop_signal.is_set():
-            self.target_function()
-            time.sleep(self.interval)
+        try:
+            while not self.stop_signal.is_set():
+                self.target_function()
+                time.sleep(self.interval)
+        except Exception as e:
+            self.exc = e
 
     def stop(self):
         """Set the stop signal to stop the thread."""
         self.stop_signal.set()
+        self.join()
+        if self.exc:
+            raise self.exc
 
+    def propagate_exception(self):
+        """Raises an exception if the target function raised an exception."""
+        if self.exc:
+            raise self.exc
diff --git a/vessim/sil/power_meter.py b/vessim/sil/power_meter.py
index 1b0b3a5..d1d9abd 100644
--- a/vessim/sil/power_meter.py
+++ b/vessim/sil/power_meter.py
@@ -1,8 +1,8 @@
 from typing import Optional
 
 from vessim.core.consumer import PowerMeter
-from vessim.sil.http_client import HTTPClient
-from vessim.sil.stoppable_thread import StoppableThread
+from vessim.sil.http_client import HttpClient
+from vessim.sil.loop_thread import LoopThread
 
 
 class HttpPowerMeter(PowerMeter):
@@ -26,9 +26,9 @@ class HttpPowerMeter(PowerMeter):
         name: Optional[str] = None
     ) -> None:
         super().__init__(name)
-        self.http_client = HTTPClient(f"{server_address}:{port}")
+        self.http_client = HttpClient(f"{server_address}:{port}")
         self.power = 0.0
-        self.update_thread = StoppableThread(self._update_power, interval)
+        self.update_thread = LoopThread(self._update_power, interval)
         self.update_thread.start()
 
     def _update_power(self) -> None:
@@ -37,6 +37,7 @@ class HttpPowerMeter(PowerMeter):
 
     def measure(self) -> float:
         """Returns the current power demand of the node."""
+        self.update_thread.propagate_exception()
         return self.power
 
     def finalize(self) -> None:
diff --git a/vessim/sil/sil_interface.py b/vessim/sil/sil_interface.py
index 645583a..c265653 100644
--- a/vessim/sil/sil_interface.py
+++ b/vessim/sil/sil_interface.py
@@ -4,9 +4,9 @@ from typing import List, Optional
 from vessim.core.storage import Storage, DefaultStoragePolicy, StoragePolicy
 from vessim.cosim._util import VessimSimulator, VessimModel, simplify_inputs
 from vessim.sil.api_server import ApiServer, VessimApi
-from vessim.sil.http_client import HTTPClient, HTTPClientError
+from vessim.sil.http_client import HttpClient
 from vessim.sil.node import Node
-from vessim.sil.stoppable_thread import StoppableThread
+from vessim.sil.loop_thread import LoopThread
 
 
 class SilInterfaceSim(VessimSimulator):
@@ -93,14 +93,14 @@ class _SilInterfaceModel(VessimModel):
         self.api_server.wait_for_startup_complete()
 
         # init server values and wait for put request confirmation
-        self.http_client = HTTPClient(f"http://{api_host}:{api_port}")
+        self.http_client = HttpClient(f"http://{api_host}:{api_port}")
         self.http_client.put("/sim/update", {
             "solar": self.p_gen,
             "ci": self.ci,
             "battery_soc": self.storage.soc(),
         })
 
-        self.collector_thread = StoppableThread(self._api_collector, collection_interval)
+        self.collector_thread = LoopThread(self._api_collector, collection_interval)
         self.collector_thread.start()
 
     def _api_collector(self):
@@ -142,6 +142,7 @@ class _SilInterfaceModel(VessimModel):
                     self.updated_nodes.append(node)
 
     def step(self, time: int, inputs: dict) -> None:
+        self.collector_thread.propagate_exception()
         inputs = simplify_inputs(inputs)
         self.p_cons = inputs["p_cons"]
         self.p_gen = inputs["p_gen"]
@@ -150,27 +151,21 @@ class _SilInterfaceModel(VessimModel):
 
         # update values to the api server
         def update_api_server():
-            try:
-                self.http_client.put("/sim/update", {
-                    "solar": self.p_gen,
-                    "ci": self.ci,
-                    "battery_soc": self.storage.soc(),
-                })
-            except HTTPClientError as e:
-                print(e)
+            self.http_client.put("/sim/update", {
+                "solar": self.p_gen,
+                "ci": self.ci,
+                "battery_soc": self.storage.soc(),
+            })
         # use thread to not slow down simulation
         api_server_update_thread = Thread(target=update_api_server)
         api_server_update_thread.start()
 
         # update power mode for the node remotely
         for node in self.updated_nodes:
-            http_client = HTTPClient(f"{node.address}:{node.port}")
+            http_client = HttpClient(f"{node.address}:{node.port}")
 
             def update_node_power_model():
-                try:
-                    http_client.put("/power_mode", {"power_mode": node.power_mode})
-                except HTTPClientError as e:
-                    print(e)
+                http_client.put("/power_mode", {"power_mode": node.power_mode})
             # use thread to not slow down simulation
             node_update_thread = Thread(target=update_node_power_model)
             node_update_thread.start()
